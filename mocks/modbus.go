// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import mock "github.com/stretchr/testify/mock"

// ModbusClient is an autogenerated mock type for the ModbusClient type
type ModbusClient struct {
	mock.Mock
}

// MaskWriteRegister provides a mock function with given fields: address, andMask, orMask
func (_m *ModbusClient) MaskWriteRegister(address uint16, andMask uint16, orMask uint16) ([]byte, error) {
	ret := _m.Called(address, andMask, orMask)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(uint16, uint16, uint16) []byte); ok {
		r0 = rf(address, andMask, orMask)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint16, uint16, uint16) error); ok {
		r1 = rf(address, andMask, orMask)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadCoils provides a mock function with given fields: address, quantity
func (_m *ModbusClient) ReadCoils(address uint16, quantity uint16) ([]byte, error) {
	ret := _m.Called(address, quantity)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(uint16, uint16) []byte); ok {
		r0 = rf(address, quantity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint16, uint16) error); ok {
		r1 = rf(address, quantity)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadDiscreteInputs provides a mock function with given fields: address, quantity
func (_m *ModbusClient) ReadDiscreteInputs(address uint16, quantity uint16) ([]byte, error) {
	ret := _m.Called(address, quantity)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(uint16, uint16) []byte); ok {
		r0 = rf(address, quantity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint16, uint16) error); ok {
		r1 = rf(address, quantity)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadFIFOQueue provides a mock function with given fields: address
func (_m *ModbusClient) ReadFIFOQueue(address uint16) ([]byte, error) {
	ret := _m.Called(address)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(uint16) []byte); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint16) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadHoldingRegisters provides a mock function with given fields: address, quantity
func (_m *ModbusClient) ReadHoldingRegisters(address uint16, quantity uint16) ([]byte, error) {
	ret := _m.Called(address, quantity)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(uint16, uint16) []byte); ok {
		r0 = rf(address, quantity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint16, uint16) error); ok {
		r1 = rf(address, quantity)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadInputRegisters provides a mock function with given fields: address, quantity
func (_m *ModbusClient) ReadInputRegisters(address uint16, quantity uint16) ([]byte, error) {
	ret := _m.Called(address, quantity)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(uint16, uint16) []byte); ok {
		r0 = rf(address, quantity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint16, uint16) error); ok {
		r1 = rf(address, quantity)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadWriteMultipleRegisters provides a mock function with given fields: readAddress, readQuantity, writeAddress, writeQuantity, value
func (_m *ModbusClient) ReadWriteMultipleRegisters(readAddress uint16, readQuantity uint16, writeAddress uint16, writeQuantity uint16, value []byte) ([]byte, error) {
	ret := _m.Called(readAddress, readQuantity, writeAddress, writeQuantity, value)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(uint16, uint16, uint16, uint16, []byte) []byte); ok {
		r0 = rf(readAddress, readQuantity, writeAddress, writeQuantity, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint16, uint16, uint16, uint16, []byte) error); ok {
		r1 = rf(readAddress, readQuantity, writeAddress, writeQuantity, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WriteMultipleCoils provides a mock function with given fields: address, quantity, value
func (_m *ModbusClient) WriteMultipleCoils(address uint16, quantity uint16, value []byte) ([]byte, error) {
	ret := _m.Called(address, quantity, value)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(uint16, uint16, []byte) []byte); ok {
		r0 = rf(address, quantity, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint16, uint16, []byte) error); ok {
		r1 = rf(address, quantity, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WriteMultipleRegisters provides a mock function with given fields: address, quantity, value
func (_m *ModbusClient) WriteMultipleRegisters(address uint16, quantity uint16, value []byte) ([]byte, error) {
	ret := _m.Called(address, quantity, value)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(uint16, uint16, []byte) []byte); ok {
		r0 = rf(address, quantity, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint16, uint16, []byte) error); ok {
		r1 = rf(address, quantity, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WriteSingleCoil provides a mock function with given fields: address, value
func (_m *ModbusClient) WriteSingleCoil(address uint16, value uint16) ([]byte, error) {
	ret := _m.Called(address, value)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(uint16, uint16) []byte); ok {
		r0 = rf(address, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint16, uint16) error); ok {
		r1 = rf(address, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WriteSingleRegister provides a mock function with given fields: address, value
func (_m *ModbusClient) WriteSingleRegister(address uint16, value uint16) ([]byte, error) {
	ret := _m.Called(address, value)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(uint16, uint16) []byte); ok {
		r0 = rf(address, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint16, uint16) error); ok {
		r1 = rf(address, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
